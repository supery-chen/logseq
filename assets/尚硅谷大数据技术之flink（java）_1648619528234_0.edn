{:highlights [{:id #uuid "62440a36-c97d-4cb0-939a-621b0e56e98b", :page 28, :position {:bounding {:x1 -0.008093699812889099, :y1 705.771728515625, :x2 721.9751586914062, :y2 749.8054809570312, :width 722, :height 1005.3286062486153}, :rects ({:x1 96.01123809814453, :y1 705.771728515625, :x2 721.9751586914062, :y2 724.771728515625, :width 722, :height 1005.3286062486153} {:x1 -0.008093699812889099, :y1 727.1804809570312, :x2 246.83384704589844, :y2 749.8054809570312, :width 722, :height 1005.3286062486153}), :page 28}, :content {:text "这里需要提到Flink中的几个关键组件：客户端（Client）、作业管理器（JobManager）和任务管理器（TaskManager）"}, :properties {:color "yellow"}} {:id #uuid "62440a74-bd5d-41e4-b278-4d1f25aaba68", :page 29, :position {:bounding {:x1 119, :y1 56, :x2 615, :y2 385, :width 722, :height 1005.3286062486153}, :rects (), :page 29}, :content {:text "[:span]", :image 1648626292381}, :properties {:color "yellow"}} {:id #uuid "62450ce5-4bd3-430d-ad09-3c77d87ceace", :page 38, :position {:bounding {:x1 96.00945281982422, :y1 269.5573425292969, :x2 446.33260345458984, :y2 288.557373046875, :width 722, :height 1005.3286062486153}, :rects ({:x1 96.00945281982422, :y1 269.5573425292969, :x2 446.33260345458984, :y2 288.557373046875, :width 722, :height 1005.3286062486153}), :page 38}, :content {:text "会话模式比较适合于单个规模小、执行时间短的大量作业"}, :properties {:color "yellow"}} {:id #uuid "62450cfa-2832-4b40-b6f9-7b46e358410e", :page 38, :position {:bounding {:x1 180.0704803466797, :y1 707.849853515625, :x2 586.4908905029297, :y2 726.849853515625, :width 722, :height 1005.3286062486153}, :rects ({:x1 180.0704803466797, :y1 707.849853515625, :x2 586.4908905029297, :y2 726.849853515625, :width 722, :height 1005.3286062486153}), :page 38}, :content {:text "单作业模式在生产环境运行更加稳定，所以是实际应用的首选模式"}, :properties {:color "yellow"}} {:id #uuid "62450d13-0ed7-4469-962b-e908d22704a6", :page 39, :position {:bounding {:x1 -0.011749267578125, :y1 132.44610595703125, :x2 721.9923095703125, :y2 196.729248046875, :width 722, :height 1005.3286062486153}, :rects ({:x1 142.9627227783203, :y1 132.44610595703125, :x2 721.9923095703125, :y2 151.44610595703125, :width 722, :height 1005.3286062486153} {:x1 -0.011749267578125, :y1 153.85235595703125, :x2 721.9876708984375, :y2 176.39923095703125, :width 722, :height 1005.3286062486153} {:x1 86.87938690185547, :y1 177.729248046875, :x2 170.93898010253906, :y2 196.729248046875, :width 722, :height 1005.3286062486153}), :page 39}, :content {:text "我们需要为每一个提交的应用单独启动一个JobManager，也就是创建一个集群。这个JobManager只为执行这一个应用而存在，执行结束之后JobManager也就关闭了，这就是所谓的应用模式"}, :properties {:color "yellow"}} {:id #uuid "62450d33-59e4-48c0-ad47-02c1bc2cd5f3", :page 39, :position {:bounding {:x1 -0.011748969554901123, :y1 460.77423095703125, :x2 721.9739110171795, :y2 550.1023559570312, :width 722, :height 1005.3286062486153}, :rects ({:x1 184.0330810546875, :y1 460.77423095703125, :x2 654.266357421875, :y2 479.77423095703125, :width 722, :height 1005.3286062486153} {:x1 -0.011748969554901123, :y1 482.18048095703125, :x2 721.9712832570076, :y2 504.74298095703125, :width 722, :height 1005.3286062486153} {:x1 -0.011745721101760864, :y1 504.82525634765625, :x2 721.9739110171795, :y2 527.3877563476562, :width 722, :height 1005.3286062486153} {:x1 -0.011742755770683289, :y1 527.4773559570312, :x2 470.11065673828125, :y2 550.1023559570312, :width 722, :height 1005.3286062486153}), :page 39}, :content {:text "在会话模式下，集群的生命周期独立于集群上运行的任何作业的生命周期，并且提交的所有作业共享资源。而单作业模式为每个提交的作业创建一个集群，带来了更好的资源隔离，这时集群的生命周期与作业的生命周期绑定。最后，应用模式为每个应用程序创建一个会话集群，在JobManager上直接调用应用程序的main()方法"}, :properties {:color "yellow"}} {:id #uuid "62450dec-7154-4f5d-819e-fc4150cff13e", :page 42, :position {:bounding {:x1 -0.008094295859336853, :y1 439.49298095703125, :x2 721.9898681640625, :y2 540.2765502929688, :width 722, :height 1005.3286062486153}, :rects ({:x1 164.640625, :y1 439.49298095703125, :x2 721.9898681640625, :y2 458.49298095703125, :width 722, :height 1005.3286062486153} {:x1 -0.008091747760772705, :y1 460.8229675292969, :x2 721.9821166992188, :y2 483.3698425292969, :width 722, :height 1005.3286062486153} {:x1 -0.008094295859336853, :y1 483.46173095703125, :x2 721.9684448242188, :y2 506.10235595703125, :width 722, :height 1005.3286062486153} {:x1 -0.00808832049369812, :y1 506.1983947753906, :x2 318.8908996582031, :y2 540.2765502929688, :width 722, :height 1005.3286062486153} {:x1 320.6511535644531, :y1 507.5265197753906, :x2 362.7403564453125, :y2 526.5265502929688, :width 722, :height 1005.3286062486153}), :page 42}, :content {:text "YARN上部署的过程是：客户端把Flink应用提交给Yarn的ResourceManager, Yarn的ResourceManager会向Yarn的NodeManager申请容器。在这些容器上，Flink会部署JobManager和TaskManager的实例，从而启动集群。Flink会根据运行在JobManger上的作业所需要的Slot数量动态分配TaskManager资源。"}, :properties {:color "yellow"}} {:id #uuid "62451f28-540a-4c62-abfe-46958ef9aef6", :page 49, :position {:bounding {:x1 90, :y1 59, :x2 653, :y2 461, :width 721.9999999999999, :height 1005.3286062486152}, :rects (), :page 49}, :content {:text "[:span]", :image 1648697128409}, :properties {:color "yellow"}} {:id #uuid "62451f57-78fd-4be4-ad93-a47a58f42523", :page 48, :position {:bounding {:x1 -0.008094727993011475, :y1 725.503173828125, :x2 721.9892578125, :y2 884.5603637695312, :width 721.9999999999999, :height 1005.3286062486152}, :rects ({:x1 127.37031555175781, :y1 725.503173828125, :x2 721.9892578125, :y2 754.846923828125, :width 721.9999999999999, :height 1005.3286062486152} {:x1 96.00971984863281, :y1 734.409423828125, :x2 635.235107421875, :y2 753.409423828125, :width 721.9999999999999, :height 1005.3286062486152} {:x1 -0.0001220703125, :y1 754.9353637695312, :x2 721.9823608398438, :y2 775.7322387695312, :width 721.9999999999999, :height 1005.3286062486152} {:x1 -0.008091211318969727, :y1 775.812255859375, :x2 721.974609375, :y2 796.609130859375, :width 721.9999999999999, :height 1005.3286062486152} {:x1 -0.0001220703125, :y1 796.7009887695312, :x2 721.9725341796875, :y2 817.5759887695312, :width 721.9999999999999, :height 1005.3286062486152} {:x1 -0.008094727993011475, :y1 817.6541137695312, :x2 205.21875, :y2 884.5603637695312, :width 721.9999999999999, :height 1005.3286062486152} {:x1 183.6564178466797, :y1 818.0916137695312, :x2 247.82403564453125, :y2 837.0916137695312, :width 721.9999999999999, :height 1005.3286062486152}), :page 48}, :content {:text "Flink的运行时架构中，最重要的就是两大组件：作业管理器（JobManger）和任务管理器（TaskManager）。对于一个提交执行的作业，JobManager是真正意义上的“管理者”（Master），负责管理调度，所以在不考虑高可用的情况下只能有一个；而TaskManager是“工作者”（Worker、Slave），负责执行任务处理数据，所以可以有一个或多个。Flink的作业提交和任务处理时的系统如图4-1所示。"}, :properties {:color "yellow"}} {:id #uuid "62453fc2-a342-43cb-8e2c-678f7917fb1d", :page 51, :position {:bounding {:x1 132, :y1 562, :x2 606, :y2 734, :width 722, :height 1005.3286062486153}, :rects (), :page 51}, :content {:text "[:span]", :image 1648705474055}, :properties {:color "yellow"}} {:id #uuid "62454063-0020-4aa4-b678-18e16e071e4f", :page 52, :position {:bounding {:x1 126, :y1 426, :x2 574, :y2 665, :width 722, :height 1005.3286062486153}, :rects (), :page 52}, :content {:text "[:span]", :image 1648705635790}, :properties {:color "yellow"}} {:id #uuid "62454115-6eba-4154-ab1d-e057d767c4a2", :page 53, :position {:bounding {:x1 119, :y1 370, :x2 654, :y2 616, :width 722, :height 1005.3286062486153}, :rects (), :page 53}, :content {:text "[:span]", :image 1648705813730}, :properties {:color "yellow"}} {:id #uuid "62454135-1954-4edb-99bf-2f6d9975f66e", :page 54, :position {:bounding {:x1 108, :y1 165, :x2 628, :y2 447, :width 722, :height 1005.3286062486153}, :rects (), :page 54}, :content {:text "[:span]", :image 1648705845181}, :properties {:color "yellow"}} {:id #uuid "624541f2-189f-4995-a375-3ef37f35add8", :page 55, :position {:bounding {:x1 107, :y1 363, :x2 601, :y2 443, :width 722, :height 1005.3286062486153}, :rects (), :page 55}, :content {:text "[:span]", :image 1648706034535}, :properties {:color "yellow"}} {:id #uuid "6245466b-87c3-47f2-b8e0-eb30d8b2cfa7", :page 55, :position {:bounding {:x1 79, :y1 457, :x2 642, :y2 683, :width 722, :height 1005.3286062486153}, :rects (), :page 55}, :content {:text "[:span]", :image 1648707179638}, :properties {:color "yellow"}} {:id #uuid "62454701-8930-4021-934b-388c85a330e5", :page 57, :position {:bounding {:x1 190, :y1 101, :x2 543, :y2 358, :width 722, :height 1005.3286062486153}, :rects (), :page 57}, :content {:text "[:span]", :image 1648707329143}, :properties {:color "yellow"}} {:id #uuid "6245471b-13ef-4cfb-975d-69af821a09d0", :page 57, :position {:bounding {:x1 -0.011749625205993652, :y1 361.59027099609375, :x2 721.9967651367188, :y2 514.2658081054688, :width 722, :height 1005.3286062486153}, :rects ({:x1 267.8672790527344, :y1 361.59027099609375, :x2 721.9942626953125, :y2 385.87152099609375, :width 722, :height 1005.3286062486153} {:x1 114.88359832763672, :y1 365.43402099609375, :x2 654.1092529296875, :y2 384.43402099609375, :width 722, :height 1005.3286062486153} {:x1 -0.011743202805519104, :y1 385.9510192871094, :x2 721.9967651367188, :y2 406.8260192871094, :width 722, :height 1005.3286062486153} {:x1 -0.01174706220626831, :y1 406.9041442871094, :x2 721.982210457325, :y2 427.7791748046875, :width 722, :height 1005.3286062486153} {:x1 -0.011749625205993652, :y1 427.8729248046875, :x2 721.9796444177628, :y2 448.7479248046875, :width 722, :height 1005.3286062486153} {:x1 -0.008644431829452515, :y1 448.8260498046875, :x2 721.9788208007812, :y2 469.6229248046875, :width 722, :height 1005.3286062486153} {:x1 -0.011743947863578796, :y1 469.702880859375, :x2 721.9738159179688, :y2 490.499755859375, :width 722, :height 1005.3286062486153} {:x1 -0.011744558811187744, :y1 490.59393310546875, :x2 335.703125, :y2 514.2658081054688, :width 722, :height 1005.3286062486153}), :page 57}, :content {:text "一个特定算子的子任务（subtask）的个数被称之为其并行度（parallelism）。这样，包含并行子任务的数据流，就是并行数据流，它需要多个分区（stream  partition）来分配并行任务。一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中，不同的算子可能具有不同的并行度。如图4-8所示，当前数据流中有source、map、window、sink四个算子，除最后sink，其他算子的并行度都为2。整个程序包含了7个子任务，至少需要2个分区来并行执行。我们可以说，这段流处理程序的并行度就是2。"}, :properties {:color "yellow"}} {:id #uuid "62454a8d-db87-42a7-838d-611c206f0a5e", :page 61, :position {:bounding {:x1 131, :y1 277, :x2 608, :y2 916, :width 722, :height 1005.3286062486153}, :rects (), :page 61}, :content {:text "[:span]", :image 1648708237078}, :properties {:color "yellow"}} {:id #uuid "62454e39-97d3-4303-a24a-a1467fc124fa", :page 63, :position {:bounding {:x1 86, :y1 623, :x2 655, :y2 914, :width 722, :height 1005.3286062486153}, :rects (), :page 63}, :content {:text "[:span]", :image 1648709177499}, :properties {:color "yellow"}} {:id #uuid "62454e59-5ef5-47ad-85b9-66b9677fa165", :page 64, :position {:bounding {:x1 -0.012770503759384155, :y1 178.26185607910156, :x2 721.997314453125, :y2 440.984130859375, :width 722, :height 1005.3286062486153}, :rects ({:x1 321.94390869140625, :y1 178.26185607910156, :x2 721.9793701171875, :y2 205.24623107910156, :width 722, :height 1005.3286062486153} {:x1 96.00971984863281, :y1 180.77748107910156, :x2 320.1858215332031, :y2 199.77748107910156, :width 722, :height 1005.3286062486153} {:x1 -0.012770503759384155, :y1 205.32569885253906, :x2 721.9720317423344, :y2 228.59132385253906, :width 722, :height 1005.3286062486153} {:x1 -0.005736827850341797, :y1 228.5986785888672, :x2 721.9789428710938, :y2 249.8330535888672, :width 722, :height 1005.3286062486153} {:x1 -0.0057320743799209595, :y1 249.9197540283203, :x2 721.9963989257812, :y2 270.7947692871094, :width 722, :height 1005.3286062486153} {:x1 -0.00809459388256073, :y1 270.8885192871094, :x2 721.9739990234375, :y2 291.7010192871094, :width 722, :height 1005.3286062486153} {:x1 -0.008093178272247314, :y1 291.776611328125, :x2 721.9934692382812, :y2 312.589111328125, :width 722, :height 1005.3286062486153} {:x1 -0.00808800756931305, :y1 312.6853942871094, :x2 721.997314453125, :y2 333.5603942871094, :width 722, :height 1005.3286062486153} {:x1 -0.00809478759765625, :y1 333.6385192871094, :x2 721.9752655029297, :y2 354.5135192871094, :width 722, :height 1005.3286062486153} {:x1 -0.008094727993011475, :y1 354.5916442871094, :x2 721.967735350132, :y2 375.4666442871094, :width 722, :height 1005.3286062486153} {:x1 -0.005731731653213501, :y1 375.5603942871094, :x2 721.9813232421875, :y2 396.4353942871094, :width 722, :height 1005.3286062486153} {:x1 -0.00809277594089508, :y1 396.5135192871094, :x2 721.995849609375, :y2 417.3103942871094, :width 722, :height 1005.3286062486153} {:x1 -0.00808839499950409, :y1 417.390380859375, :x2 340.34051513671875, :y2 440.984130859375, :width 722, :height 1005.3286062486153}), :page 64}, :content {:text "我们可以通过集群的配置文件来设定TaskManager的slot数量：taskmanager.numberOfTaskSlots: 8通过调整slot的数量，我们就可以控制子任务之间的隔离级别。具体来说，如果一个TaskManager只有一个slot，那将意味着每个任务都会运行在独立的JVM中（当然，该JVM可能是通过一个特定的容器启动的）；而一个TaskManager设置多个slot则意味着多个子任务可以共享同一个JVM。它们的区别在于：前者任务之间完全独立运行，隔离级别更高、彼此间的影响可以降到最小；而后者在同一个JVM进程中运行的任务，将共享TCP连接和心跳消息，也可能共享数据集和数据结构，这就减少了每个任务的运行开销，在降低隔离级别的同时提升了性能。需要注意的是，slot目前仅仅用来隔离内存，不会涉及CPU的隔离。在具体应用时，可以将slot数量配置为机器的CPU核心数，尽量避免不同任务之间对CPU的竞争。这也是开发环境默认并行度设为机器CPU数量的原因。"}, :properties {:color "yellow"}} {:id #uuid "62454e82-ff8f-4b89-b726-614cb95daff5", :page 64, :position {:bounding {:x1 57, :y1 662, :x2 613, :y2 926, :width 722, :height 1005.3286062486153}, :rects (), :page 64}, :content {:text "[:span]", :image 1648709252945}, :properties {:color "yellow"}} {:id #uuid "62454e91-b72e-43b4-86a2-5c5565148a9e", :page 65, :position {:bounding {:x1 269.03875732421875, :y1 127.34027099609375, :x2 539.35205078125, :y2 151.54339599609375, :width 722, :height 1005.3286062486153}, :rects ({:x1 353.140625, :y1 127.34027099609375, :x2 523.5791625976562, :y2 151.54339599609375, :width 722, :height 1005.3286062486153} {:x1 269.03875732421875, :y1 131.18402099609375, :x2 382.7509460449219, :y2 150.18402099609375, :width 722, :height 1005.3286062486153} {:x1 525.30419921875, :y1 131.18402099609375, :x2 539.35205078125, :y2 150.18402099609375, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "默认情况下，Flink是允许子任务共享slot的"}, :properties {:color "yellow"}} {:id #uuid "62454ee2-c050-42d0-a67a-8d1e48e7e94f", :page 65, :position {:bounding {:x1 -0.01174953579902649, :y1 151.984130859375, :x2 721.9873657226562, :y2 298.015380859375, :width 722, :height 1005.3286062486153}, :rects ({:x1 86.87904357910156, :y1 151.984130859375, :x2 721.9708251953125, :y2 170.984130859375, :width 722, :height 1005.3286062486153} {:x1 -0.011747121810913086, :y1 172.49786376953125, :x2 721.9742431640625, :y2 193.37286376953125, :width 722, :height 1005.3286062486153} {:x1 -0.01174953579902649, :y1 193.45098876953125, :x2 721.9864501953125, :y2 214.32598876953125, :width 722, :height 1005.3286062486153} {:x1 -0.011743947863578796, :y1 214.40411376953125, :x2 721.96875, :y2 235.27911376953125, :width 722, :height 1005.3286062486153} {:x1 -0.008644431829452515, :y1 235.37286376953125, :x2 721.978515625, :y2 256.2479248046875, :width 722, :height 1005.3286062486153} {:x1 -0.011748388409614563, :y1 256.3260498046875, :x2 721.9873657226562, :y2 277.1229248046875, :width 722, :height 1005.3286062486153} {:x1 -0.011742889881134033, :y1 277.202880859375, :x2 412.1725158691406, :y2 298.015380859375, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个slot上执行。所以对于第一个任务节点source→map，它的6个并行子任务必须分到不同的slot上（如果在同一slot就没法数据并行了），而第二个任务节点keyBy/window/apply的并行子任务却可以和第一个任务节点共享slot。于是最终结果就变成了：每个任务节点的并行子任务一字排开，占据不同的slot；而不同的任务节点的子任务可以共享slot。一个slot中，可以将程序处理的所有任务都放在这里执行，我们把它叫作保存了整个作业的运行管道（pipeline）。"}, :properties {:color "yellow"}} {:id #uuid "62454f17-cf32-4f0c-b7c4-06f09a36058b", :page 65, :position {:bounding {:x1 -0.01174953579902649, :y1 549.7634887695312, :x2 721.9903564453125, :y2 612.1072387695312, :width 722, :height 1005.3286062486153}, :rects ({:x1 365.5645751953125, :y1 549.7634887695312, :x2 654.2659301757812, :y2 568.7634887695312, :width 722, :height 1005.3286062486153} {:x1 -0.01174953579902649, :y1 570.2791137695312, :x2 721.9903564453125, :y2 591.1541137695312, :width 722, :height 1005.3286062486153} {:x1 -0.011745616793632507, :y1 591.2322387695312, :x2 176.953125, :y2 612.1072387695312, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "当我们将资源密集型和非密集型的任务同时放到一个slot中，它们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的TaskManager。"}, :properties {:color "yellow"}} {:id #uuid "62454f2b-de44-4b9a-bef3-00b9580a1ecb", :page 65, :position {:bounding {:x1 -0.011747926473617554, :y1 612.6384887695312, :x2 721.9775390625, :y2 653.9509887695312, :width 722, :height 1005.3286062486153}, :rects ({:x1 114.8781967163086, :y1 612.6384887695312, :x2 721.9775390625, :y2 631.6384887695312, :width 722, :height 1005.3286062486153} {:x1 -0.011747926473617554, :y1 633.1541137695312, :x2 535.29541015625, :y2 653.9509887695312, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "slot共享另一个好处就是允许我们保存完整的作业管道。这样一来，即使某个TaskManager出现故障宕机，其他节点也可以完全不受影响，作业的任务可以继续执行"}, :properties {:color "yellow"}} {:id #uuid "62454f43-7104-418b-a2e3-2e593ce87043", :page 65, :position {:bounding {:x1 -0.011747121810913086, :y1 654.390380859375, :x2 722.00537109375, :y2 736.2947387695312, :width 722, :height 1005.3286062486153}, :rects ({:x1 114.88580322265625, :y1 654.390380859375, :x2 722.00537109375, :y2 673.390380859375, :width 722, :height 1005.3286062486153} {:x1 -0.011747121810913086, :y1 674.9041137695312, :x2 721.9780883789062, :y2 695.7947387695312, :width 722, :height 1005.3286062486153} {:x1 -0.011746898293495178, :y1 695.8841552734375, :x2 721.9851684570312, :y2 716.7747802734375, :width 722, :height 1005.3286062486153} {:x1 86.87538146972656, :y1 717.2947387695312, :x2 213.03448486328125, :y2 736.2947387695312, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "另外，同一个任务节点的并行子任务是不能共享slot的，所以允许slot共享之后，运行作业所需的slot数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需要配置多少slot资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看最大的并行度就够了"}, :properties {:color "yellow"}} {:id #uuid "62454f5f-ecb2-4910-8248-aed5113b5b47", :page 65, :position {:bounding {:x1 -0.01174953579902649, :y1 738.2634887695312, :x2 721.9948120117188, :y2 879.1411743164062, :width 722, :height 1005.3286062486153}, :rects ({:x1 114.888427734375, :y1 738.2634887695312, :x2 721.984375, :y2 759.1384887695312, :width 722, :height 1005.3286062486153} {:x1 -0.011747851967811584, :y1 758.7791137695312, :x2 721.979736328125, :y2 779.5759887695312, :width 722, :height 1005.3286062486153} {:x1 -0.01174953579902649, :y1 779.656005859375, :x2 721.9840390384197, :y2 799.359130859375, :width 722, :height 1005.3286062486153} {:x1 -0.00080108642578125, :y1 799.4451293945312, :x2 721.9948120117188, :y2 817.5857543945312, :width 722, :height 1005.3286062486153} {:x1 89.78044891357422, :y1 801.7888793945312, :x2 456.9737854003906, :y2 813.7888793945312, :width 722, :height 1005.3286062486153} {:x1 478.59375, :y1 801.7888793945312, :x2 493.0041809082031, :y2 813.7888793945312, :width 722, :height 1005.3286062486153} {:x1 -0.008642926812171936, :y1 817.5986938476562, :x2 721.983642578125, :y2 838.7549438476562, :width 722, :height 1005.3286062486153} {:x1 -0.011748388409614563, :y1 838.843505859375, :x2 721.9830932617188, :y2 859.624755859375, :width 722, :height 1005.3286062486153} {:x1 86.8905029296875, :y1 860.1411743164062, :x2 255.06129455566406, :y2 879.1411743164062, :width 722, :height 1005.3286062486153}), :page 65}, :content {:text "当然，Flink默认是允许slot共享的，如果希望某个算子对应的任务完全独占一个slot，或者只有某一部分算子共享slot，我们也可以通过设置“slot共享组”（SlotSharingGroup）手动指定：.map(word -> Tuple2.of(word, 1L)).slotSharingGroup(“1”);这样，只有属于同一个slot共享组的子任务，才会开启slot共享；不同组之间的任务是完全隔离的，必须分配到不同的slot上。在这种场景下，总共需要的slot数量，就是各个slot共享组最大并行度的总和。"}, :properties {:color "yellow"}} {:id #uuid "624551f0-6d44-4f88-b3d9-9d73db8febc9", :page 69, :position {:bounding {:x1 88, :y1 319, :x2 584, :y2 413, :width 722, :height 1005.3286062486153}, :rects (), :page 69}, :content {:text "[:span]", :image 1648710128297}, :properties {:color "yellow"}} {:id #uuid "6245531d-7ab5-43c2-8e46-cace6d0eb13c", :page 69, :position {:bounding {:x1 89.7641372680664, :y1 861.6134033203125, :x2 658.2296600341797, :y2 890.8915405273438, :width 722, :height 1005.3286062486153}, :rects ({:x1 89.77494812011719, :y1 861.6134033203125, :x2 658.2296600341797, :y2 873.6134033203125, :width 722, :height 1005.3286062486153} {:x1 89.7641372680664, :y1 878.8915405273438, :x2 471.3401870727539, :y2 890.8915405273438, :width 722, :height 1005.3286062486153}), :page 69}, :content {:text "StreamExecutionEnvironment                        env                        = StreamExecutionEnvironment.getExecutionEnvironment();"}, :properties {:color "yellow"}} {:id #uuid "62455327-4900-47c2-a95b-64c588a3069e", :page 70, :position {:bounding {:x1 70.84210205078125, :y1 207.3450927734375, :x2 721.9764404296875, :y2 236.62591552734375, :width 722, :height 1005.3286062486153}, :rects ({:x1 70.84210205078125, :y1 207.3450927734375, :x2 721.9764404296875, :y2 219.3450927734375, :width 722, :height 1005.3286062486153} {:x1 70.85724639892578, :y1 224.62591552734375, :x2 445.2280960083008, :y2 236.62591552734375, :width 722, :height 1005.3286062486153}), :page 70}, :content {:text "StreamExecutionEnvironment                     localEnv                     = StreamExecutionEnvironment.createLocalEnvironment();"}, :properties {:color "yellow"}} {:id #uuid "62455333-4059-4d0a-a266-e4d36f31f389", :page 70, :position {:bounding {:x1 -0.009825989603996277, :y1 318.5638427734375, :x2 721.9963989257812, :y2 417.13525390625, :width 722, :height 1005.3286062486153}, :rects ({:x1 70.85724639892578, :y1 318.5638427734375, :x2 538.8208084106445, :y2 330.5638427734375, :width 722, :height 1005.3286062486153} {:x1 -0.00263214111328125, :y1 333.21966552734375, :x2 721.9930419921875, :y2 350.46966552734375, :width 722, :height 1005.3286062486153} {:x1 124.01299285888672, :y1 335.84466552734375, :x2 303.99688720703125, :y2 347.84466552734375, :width 722, :height 1005.3286062486153} {:x1 -0.009825989603996277, :y1 350.50091552734375, :x2 721.9963989257812, :y2 368.65716552734375, :width 722, :height 1005.3286062486153} {:x1 -0.009825989603996277, :y1 367.8583984375, :x2 721.9755859375, :y2 385.6083984375, :width 722, :height 1005.3286062486153} {:x1 -0.009825989603996277, :y1 385.61962890625, :x2 721.9801635742188, :y2 402.88525390625, :width 722, :height 1005.3286062486153} {:x1 124.00582885742188, :y1 405.13525390625, :x2 145.62147521972656, :y2 417.13525390625, :width 722, :height 1005.3286062486153}), :page 70}, :content {:text "StreamExecutionEnvironment remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment(\"host\", // JobManager主机名1234, // JobManager进程端口号\"path/to/jarFile.jar\"// 提交给JobManager的JAR包); "}, :properties {:color "yellow"}} {:id #uuid "6245533d-b444-4af3-855e-91035b9a28e8", :page 70, :position {:bounding {:x1 -0.008092910051345825, :y1 424.1331787109375, :x2 721.9904422461987, :y2 488.57110595703125, :width 722, :height 1005.3286062486153}, :rects ({:x1 96.00318145751953, :y1 424.1331787109375, :x2 635.3948440551758, :y2 443.1331787109375, :width 722, :height 1005.3286062486153} {:x1 -0.008092910051345825, :y1 445.53985595703125, :x2 721.9904422461987, :y2 468.16485595703125, :width 722, :height 1005.3286062486153} {:x1 67.98240661621094, :y1 469.57110595703125, :x2 278.2424011230469, :y2 488.57110595703125, :width 722, :height 1005.3286062486153}), :page 70}, :content {:text "在获取到程序执行环境后，我们还可以对执行环境进行灵活的设置。比如可以全局设置程序的并行度、禁用算子链，还可以定义程序的时间语义、配置容错机制。关于时间语义和容错机制，我们会在后续的章节介绍。"}, :properties {:color "yellow"}} {:id #uuid "624553b8-d0e6-46c6-908f-3c6be96c2c9f", :page 71, :position {:bounding {:x1 89.7641372680664, :y1 362.7044677734375, :x2 406.573974609375, :y2 381.6419677734375, :width 722, :height 1005.3286062486153}, :rects ({:x1 190.5625, :y1 362.7044677734375, :x2 333.3706359863281, :y2 381.6419677734375, :width 722, :height 1005.3286062486153} {:x1 89.7641372680664, :y1 364.6419677734375, :x2 406.573974609375, :y2 376.6419677734375, :width 722, :height 1005.3286062486153}), :page 71}, :content {:text "bin/flink run -Dexecution.runtime-mode=BATCH"}, :properties {:color "yellow"}} {:id #uuid "6245550b-ea82-43bc-ab73-c4b9d079dd19", :page 72, :position {:bounding {:x1 109, :y1 515, :x2 590, :y2 601, :width 722, :height 1005.3286062486153}, :rects (), :page 72}, :content {:text "[:span]", :image 1648710923832}, :properties {:color "yellow"}} {:id #uuid "62466b57-e09a-407f-bdf8-4e7212545c6e", :page 82, :position {:bounding {:x1 85, :y1 357, :x2 687, :y2 464, :width 800, :height 1113.937513848881}, :rects (), :page 82}, :content {:text "[:span]", :image 1648782167373}, :properties {:color "yellow"}} {:id #uuid "6246c794-102a-411c-8d96-1a780b226178", :page 96, :position {:bounding {:x1 -0.00979013741016388, :y1 781.4329833984375, :x2 799.9881591796875, :y2 932.1044311523438, :width 800, :height 1113.937513848881}, :rects ({:x1 224.894775390625, :y1 781.4329833984375, :x2 799.9881591796875, :y2 809.2923583984375, :width 800, :height 1113.937513848881} {:x1 98.58726501464844, :y1 786.6048583984375, :x2 222.8818817138672, :y2 806.6048583984375, :width 800, :height 1113.937513848881} {:x1 -0.00979013741016388, :y1 809.911865234375, :x2 799.9842529296875, :y2 834.380615234375, :width 800, :height 1113.937513848881} {:x1 -0.009788081049919128, :y1 834.9950561523438, :x2 799.9869537353516, :y2 859.5575561523438, :width 800, :height 1113.937513848881} {:x1 -0.004230603575706482, :y1 860.1669311523438, :x2 799.9848441034555, :y2 884.6356811523438, :width 800, :height 1113.937513848881} {:x1 -0.009789690375328064, :y1 885.239990234375, :x2 799.9852664619684, :y2 909.708740234375, :width 800, :height 1113.937513848881} {:x1 75.31381225585938, :y1 912.1044311523438, :x2 184.17691040039062, :y2 932.1044311523438, :width 800, :height 1113.937513848881}), :page 96}, :content {:text "“富函数类”也是DataStream  API提供的一个函数类的接口，所有的Flink函数类都有其Rich版本。富函数类一般是以抽象类的形式出现的。例如：RichMapFunction、RichFilterFunction、RichReduceFunction等。既然“富”，那么它一定会比常规的函数类提供更多、更丰富的功能。与常规函数类的不同主要在于，富函数类可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能。"}, :properties {:color "yellow"}} {:id #uuid "624d0a28-e019-4df0-b32c-11d000f59cf8", :page 106, :position {:bounding {:x1 116, :y1 190, :x2 651, :y2 297, :width 800, :height 1113.937513848881}, :rects (), :page 106}, :content {:text "[:span]", :image 1649216040884}, :properties {:color "yellow"}} {:id #uuid "624d0aa0-3e59-4af2-87e7-97cfae105126", :page 107, :position {:bounding {:x1 91, :y1 285, :x2 731, :y2 927, :width 800, :height 1113.937513848881}, :rects (), :page 107}, :content {:text "[:span]", :image 1649216160184}, :properties {:color "yellow"}} {:id #uuid "624d5897-727a-4259-ba83-8dfcd325e250", :page 108, :position {:bounding {:x1 -0.009789541363716125, :y1 302.7243347167969, :x2 799.9926147460938, :y2 375.8075866699219, :width 800, :height 1113.937513848881}, :rects ({:x1 106.38900756835938, :y1 302.7243347167969, :x2 799.9926147460938, :y2 322.7243347167969, :width 800, :height 1113.937513848881} {:x1 -0.009789541363716125, :y1 326.1448059082031, :x2 799.98681640625, :y2 350.7229309082031, :width 800, :height 1113.937513848881} {:x1 -0.009785771369934082, :y1 351.3388366699219, :x2 213.39759826660156, :y2 375.8075866699219, :width 800, :height 1113.937513848881}), :page 108}, :content {:text "Flink为此专门提供了一个流式文件系统的连接器：StreamingFileSink，它继承自抽象类RichSinkFunction，而且集成了Flink的检查点（checkpoint）机制，用来保证精确一次（exactly once）的一致性语义"}, :properties {:color "yellow"}} {:id #uuid "624d58b3-f284-494c-b4db-60cdbbf1b3bf", :page 108, :position {:bounding {:x1 -0.009788185358047485, :y1 528.786865234375, :x2 799.9979858398438, :y2 601.8544311523438, :width 800, :height 1113.937513848881}, :rects ({:x1 106.38325500488281, :y1 528.786865234375, :x2 799.984375, :y2 553.271240234375, :width 800, :height 1113.937513848881} {:x1 -0.009788185358047485, :y1 552.1990356445312, :x2 799.9979858398438, :y2 576.7771606445312, :width 800, :height 1113.937513848881} {:x1 -0.009785011410713196, :y1 577.3856811523438, :x2 273.3728942871094, :y2 601.8544311523438, :width 800, :height 1113.937513848881}), :page 108}, :content {:text "StreamingFileSink支持行编码（Row-encoded）和批量编码（Bulk-encoded，比如Parquet）格式。这两种不同的方式都有各自的构建器（builder），调用方法也非常简单，可以直接调用StreamingFileSink的静态方法"}, :properties {:color "yellow"}} {:id #uuid "624d5a84-e517-4adc-82bd-457353787338", :page 110, :position {:bounding {:x1 -0.00978851318359375, :y1 -0.009063720703125, :x2 799.9957885742188, :y2 242.43255615234375, :width 800, :height 1113.937513848881}, :rects ({:x1 520.1137084960938, :y1 -0.009063720703125, :x2 799.9957885742188, :y2 144.69406127929688, :width 800, :height 1113.937513848881} {:x1 485.984375, :y1 121.91281127929688, :x2 518.8026123046875, :y2 141.91281127929688, :width 800, :height 1113.937513848881} {:x1 -0.00978851318359375, :y1 145.30755615234375, :x2 799.9874877929688, :y2 169.87005615234375, :width 800, :height 1113.937513848881} {:x1 -0.009786650538444519, :y1 170.47943115234375, :x2 799.991943359375, :y2 194.94818115234375, :width 800, :height 1113.937513848881} {:x1 -0.009786650538444519, :y1 195.56808471679688, :x2 799.9818725585938, :y2 220.036865234375, :width 800, :height 1113.937513848881} {:x1 75.3202133178711, :y1 222.43255615234375, :x2 401.4337387084961, :y2 242.43255615234375, :width 800, :height 1113.937513848881}), :page 110}, :content {:text "Flink官方为Kafka提供了Source和Sink的连接器，我们可以用它方便地从Kafka读写数据。如果仅仅是支持读写，那还说明不了Kafka和Flink关系的亲密；真正让它们密不可分的是，Flink与Kafka的连接器提供了端到端的精确一次（exactlyonce）语义保证，这在实际项目中是最高级别的一致性保证。关于这部分内容，我们会在后续章节做更详细的讲解"}, :properties {:color "yellow"}} {:id #uuid "624d5dd4-ef84-4514-a23e-b3ffdff8cac0", :page 111, :position {:bounding {:x1 -0.009467989206314087, :y1 616.7450561523438, :x2 800.0007934570312, :y2 712.0731811523438, :width 800, :height 1113.937513848881}, :rects ({:x1 127.29585266113281, :y1 616.7450561523438, :x2 799.9992065429688, :y2 636.7450561523438, :width 800, :height 1113.937513848881} {:x1 -0.009467989206314087, :y1 640.036865234375, :x2 800.0007934570312, :y2 664.505615234375, :width 800, :height 1113.937513848881} {:x1 -0.009462624788284302, :y1 665.1200561523438, :x2 799.9901733398438, :y2 689.6825561523438, :width 800, :height 1113.937513848881} {:x1 96.26974487304688, :y1 692.0731811523438, :x2 422.3832702636719, :y2 712.0731811523438, :width 800, :height 1113.937513848881}), :page 111}, :content {:text "Flink没有直接提供官方的Redis连接器，不过Bahir项目还是担任了合格的辅助角色，为我们提供了Flink-Redis的连接工具。但版本升级略显滞后，目前连接器版本为1.0，支持的Scala版本最新到2.11。由于我们的测试不涉及到Scala的相关版本变化，所以并不影响使用。在实际项目应用中，应该以匹配的组件版本运行"}, :properties {:color "yellow"}} {:id #uuid "624d64b8-ea6f-4870-a0b3-edacc8bbdc83", :page 113, :position {:bounding {:x1 -0.015334829688072205, :y1 399.7298278808594, :x2 800.006591796875, :y2 534.5575561523438, :width 800, :height 1113.937513848881}, :rects ({:x1 213.81507873535156, :y1 399.7298278808594, :x2 800.006591796875, :y2 434.0423278808594, :width 800, :height 1113.937513848881} {:x1 127.29486083984375, :y1 411.2610778808594, :x2 211.8882293701172, :y2 431.2610778808594, :width 800, :height 1113.937513848881} {:x1 640.25, :y1 411.2610778808594, :x2 724.6717529296875, :y2 431.2610778808594, :width 800, :height 1113.937513848881} {:x1 -0.009463220834732056, :y1 434.6513366699219, :x2 800.0010375976562, :y2 459.2138366699219, :width 800, :height 1113.937513848881} {:x1 -0.00946451723575592, :y1 459.8232116699219, :x2 799.9822957366705, :y2 484.2919616699219, :width 800, :height 1113.937513848881} {:x1 -0.015334829688072205, :y1 484.9118347167969, :x2 799.9931030273438, :y2 509.3805847167969, :width 800, :height 1113.937513848881} {:x1 -0.009464949369430542, :y1 509.9950866699219, :x2 180.87240600585938, :y2 534.5575561523438, :width 800, :height 1113.937513848881}), :page 113}, :content {:text "ElasticSearch是一个分布式的开源搜索和分析引擎，适用于所有类型的数据。ElasticSearch有着简洁的REST风格的API，以良好的分布式特性、速度和可扩展性而闻名，在大数据领域应用非常广泛。Flink为ElasticSearch专门提供了官方的Sink 连接器，Flink1.13支持当前最新版本的ElasticSearch"}, :properties {:color "yellow"}} {:id #uuid "624d64f5-9a95-43e3-80a3-e8dec01baee7", :page 116, :position {:bounding {:x1 -0.009789779782295227, :y1 165.69859313964844, :x2 799.9995513558388, :y2 275.3388366699219, :width 800, :height 1113.937513848881}, :rects ({:x1 465.8512878417969, :y1 165.69859313964844, :x2 799.9835815429688, :y2 200.01109313964844, :width 800, :height 1113.937513848881} {:x1 106.37696838378906, :y1 177.22984313964844, :x2 463.4549102783203, :y2 197.22984313964844, :width 800, :height 1113.937513848881} {:x1 -0.009785011410713196, :y1 200.6200714111328, :x2 799.9840087890625, :y2 225.0888214111328, :width 800, :height 1113.937513848881} {:x1 -0.009787023067474365, :y1 225.69308471679688, :x2 799.9995513558388, :y2 250.16183471679688, :width 800, :height 1113.937513848881} {:x1 -0.009789779782295227, :y1 250.7763214111328, :x2 638.8895874023438, :y2 275.3388366699219, :width 800, :height 1113.937513848881}), :page 116}, :content {:text "关系型数据库有着非常好的结构化数据设计、方便的SQL查询，是很多企业中业务数据存储的主要形式。MySQL就是其中的典型代表。尽管在大数据处理中直接与MySQL交互的场景不多，但最终处理的计算结果是要给外部应用消费使用的，而外部应用读取的数据存储往往就是MySQL。所以我们也需要知道如何将数据输出到MySQL这样的传统数据库"}, :properties {:color "yellow"}} {:id #uuid "624d6516-35c7-44f1-90f2-f292732b462b", :page 118, :position {:bounding {:x1 -0.00978650152683258, :y1 147.0888214111328, :x2 799.9957275390625, :y2 217.25558471679688, :width 800, :height 1113.937513848881}, :rects ({:x1 106.38639068603516, :y1 147.0888214111328, :x2 799.9839477539062, :y2 167.0888214111328, :width 800, :height 1113.937513848881} {:x1 -0.00978650152683258, :y1 170.4794464111328, :x2 799.9957275390625, :y2 194.94818115234375, :width 800, :height 1113.937513848881} {:x1 75.31902313232422, :y1 197.25558471679688, :x2 121.75395202636719, :y2 217.25558471679688, :width 800, :height 1113.937513848881}), :page 118}, :content {:text "与Source类似，Flink为我们提供了通用的SinkFunction接口和对应的RichSinkDunction抽象类，只要实现它，通过简单地调用DataStream的.addSink()方法就可以自定义写入任何外部存储"}, :properties {:color "yellow"}} {:id #uuid "624d6528-9cff-4418-bfb0-3644bff5f1a3", :page 118, :position {:bounding {:x1 75.31798553466797, :y1 272.5837097167969, :x2 799.995849609375, :y2 317.7607116699219, :width 800, :height 1113.937513848881}, :rects ({:x1 106.38720703125, :y1 272.5837097167969, :x2 799.995849609375, :y2 292.5837097167969, :width 800, :height 1113.937513848881} {:x1 75.31798553466797, :y1 297.7607116699219, :x2 323.7907028198242, :y2 317.7607116699219, :width 800, :height 1113.937513848881}), :page 118}, :content {:text "在实现SinkFunction的时候，需要重写的一个关键方法invoke()，在这个方法中我们就可以实现将流里的数据发送出去的逻辑"}, :properties {:color "yellow"}} {:id #uuid "624d73cd-f0f4-4503-8c5b-a249320e88a2", :page 120, :position {:bounding {:x1 -0.009787902235984802, :y1 627.1887817382812, :x2 799.9993676245213, :y2 716.6731567382812, :width 800, :height 1113.937513848881}, :rects ({:x1 106.3875732421875, :y1 627.1887817382812, :x2 704.0524291992188, :y2 647.1887817382812, :width 800, :height 1113.937513848881} {:x1 -0.009787648916244507, :y1 649.5274047851562, :x2 799.9993676245213, :y2 672.0430297851562, :width 800, :height 1113.937513848881} {:x1 -0.009787902235984802, :y1 672.6575317382812, :x2 799.9842529296875, :y2 695.2512817382812, :width 800, :height 1113.937513848881} {:x1 75.31381225585938, :y1 696.6731567382812, :x2 168.622802734375, :y2 716.6731567382812, :width 800, :height 1113.937513848881}), :page 120}, :content {:text "在流数据处理应用中，一个很重要、也很常见的操作就是窗口计算。所谓的“窗口”，一般就是划定的一段时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。接下来我们就深入了解一下Flink中的时间语义和窗口的应用"}, :properties {:color "yellow"}} {:id #uuid "624d73e6-ad9f-4d11-bcb7-dec87e9b12b7", :page 121, :position {:bounding {:x1 129, :y1 641, :x2 674, :y2 917, :width 800, :height 1113.937513848881}, :rects (), :page 121}, :content {:text "[:span]", :image 1649243110616}, :properties {:color "yellow"}}]}