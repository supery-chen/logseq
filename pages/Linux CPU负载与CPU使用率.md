public:: true

- [详解Linux CPU负载和CPU使用率](https://cloud.tencent.com/developer/article/1722207)
- **CPU负载**
- > 指某段时间内占用cpu时间的进程和等待cpu时间的进程数,这里等待cpu时间的进程指等待被唤醒的进程,不包括处于wait状态的进程
- **CPU使用率**
- > 反应当前cpu的繁忙程度,忽高忽低的原因在于占用cpu处理时间的进程可能处于io等待状态但却还未释放进入wait
-
- ## CPU负载的一个类比
	- 假设最简单的情况,你的电脑只有一个CPU,所有的运算都必须由这个CPU来完成
	- 那么,我们不妨把这个CPU想象成一座大桥,桥上只有一根车道,所有车辆都必须从这根车道上通过(很显然,这座桥只能单向通行)
	- 系统负载为0,意味着大桥上一辆车都没有
	- 系统负载为0.5,意味着大桥上一半的路段有车
	- 系统负载为1.0,意味着大桥上所有路段都有车,也就是说大桥已经**满**了.但必须注意的是,直到此时大桥还是能顺畅通行的
	- 系统负载为1.7,意味着车辆太多,大桥已被占满,后面还有桥面车辆的70%在等待上桥.所以,系统负载超过1后,后面的车辆就必须等待,负载越高,等待越久
	- CPU的系统负荷,基本上等同于上面的类比.大桥的通行能力,就是CPU的最大工作量;桥梁上的车辆,就是一个个等待CPU处理的进程(process)
	- 为了电脑顺畅运行,系统负荷最好不要超过1.0,这样就没有进程需要等待了,所有进程都能第一时间得到处理.很显然,1.0是一个关键值,超过这个值,系统就不在最佳状态了,你要动手干预了
-
- ## CPU负载-多处理器
	- 2个CPU表明系统负荷可以达到2.0,此时每个CPU都达到100%的工作量.推广开来,n个CPU的电脑,可接受的系统负荷最大为n.0
-
- ## CPU负载-多核处理器
	- 多核CPU与多CPU效果类似,等价于CPU数*每个CPU核心数
	- `cat /proc/cpuinfo` 可以查看CPU信息
	- `grep -c 'model name' /proc/cpuinfo` 可以直接查看CPU总核心数
-
- ## 系统负载的经验法则
	- 平均到每个核心来看
		- 当负载持续大于0.7,你必须开始调查了,问题出在哪里,防止情况恶化
		- 当负载持续大于1.0,你必须动手寻找解决办法,把这个值降下来
		- 当负载达到5.0,就表明你的系统有很严重的问题,长时间没有响应,或者接近死机了.你不应该让系统达到这个值