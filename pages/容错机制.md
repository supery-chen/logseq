- ((6253c3a2-7b64-4859-8719-d84f591ab24e))
- ## 检查点
  collapsed:: true
	- ((6253c3c4-13e8-4dce-8482-d4879add0889))
	- ((6253c3d3-5644-4c9a-9d4c-5cd856d81862))
	- ### 检查点的保存
		- #### 周期性的触发保存
			- ((6253c401-5d88-4cc4-846b-8a045125dd27))
			- ((6253c422-52a2-46f4-8d2f-29b3268f30d4))
				- ((6253c480-d178-4a52-acc8-58602802e6b6))
			- ((6253c497-aa8d-493c-bc92-d1c0de5f6f87))
				- [[$red]]==我不理解==
	- ### 从检查点恢复状态
		- ((6253c6f1-f9f6-4358-b721-1cf31c91debd))
		- ((6253c6f8-249c-4710-867a-fbb1a0ad6cd0))
		- ((6253c6fe-1da7-4a89-8451-9a520516267a))
		- ((6253c703-5b6d-4123-9851-7d8dff3bf72a))
	- ### 检查点算法
		- ((6253c800-8cff-46af-8feb-25456e037129))
		- #### 检查点分界线(Barrier)
			- ((6253c82b-1bd1-4111-a5d8-ad5cad0161da))
				- ((6253ca07-1a2b-492e-b579-1c0fca818e3c))
			- ((6253ca11-0281-4d46-8390-8be817ed9eb7))
				- ((6253ca50-fae3-44e3-89d6-d9b3a6b980d7))
				- ((6253ca73-f5ca-495b-a05f-de3fc986638e))
				- ((6253d0cd-4da5-4e96-a132-185c46e2d989))
	- ### 检查点配置
		- ((6253d102-3da8-49b9-87e9-11d132a46ca5))
		- #### 启用检查点
			- ((6253d16b-16f5-4efb-babd-7ba92cb7d28d))
			- 默认是禁用检查点的,可以通过`enableCheckpointing`进行开启
			- ```java
			  StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
			  // 每隔1秒启动一次检查点保存
			  env.enableCheckpointing(1000);
			  ```
		- #### 检查点存储
			- ((6253d162-7dc3-410e-a931-449605c8a7c4))
			- ((6253d183-d524-44d0-b73f-a4735823b34a))
			- ((6253d18c-4f3e-4244-aaf9-8b1f3867d2a2))
		- #### 其他高级配置
			- ((6253d1a7-a016-430a-916b-dad141b0fa76))
			- ((6253d1b6-4441-4036-a0a9-f6e6ccffaf17))
			- ((6253d1bb-f4dd-4d09-a30e-00dc89ea59fd))
			- ((6253d1c2-672e-4010-93d2-a24a6130297f))
			- ((6253d1dd-3797-40dd-b329-55e42f9a5799))
			- ((6253d1e5-7438-4c5d-82e2-cef501baf7e8))
			- ((6253d1f7-88ed-425a-a684-12488ea164e4))
			- ((6253d202-6631-4c11-b1a0-972bf644234f))
	- ### 保存点
		- ((6253d349-11b7-4bc7-9ec9-398a2721477f))
		- ((6253d361-6ab0-4dd1-8191-35fc63a2859f))
		- ((6253d386-62d9-4951-aa82-7154ca232df0))
		- ((6253d39d-c199-495c-bf3f-8ac9f83c52b1))
- ## 状态一致性
	- AT-MOST-ONCE
	- AT-LEAST-ONCE
	- EXACTLY-ONCE
	- ((6253dbf4-c9ac-492c-855d-33517d808b9e))
- ## 端到端精确一次(end-to-end exactly-once)
	- 检查点机制可以保证故障恢复后数据不丢(在能重放的前提下),并且只处理一次,所以已经可以做到exactly-once的一致性语义了
	- ### 输入端保证
		- 必须拥有重放数据的能力.一个最经典的应用就是Kafka
		- ((6253e4da-412f-4bc3-b483-4aba689f82fd))
	- ### 输出端保证
		- #### 幂等写入
			- ((6253e518-fdc7-4c16-b4fa-eba861488a06))
			- 最典型的就是对HashMap的插入操作
			- ((6253e569-7989-4dc3-beeb-7d2bfc0bd1a6))
		- #### 事务写入
			- ((6253e52b-55a7-4546-a779-94d8cbc5094c))
			- 事务写入是更一般化的保证一致性的方式
			- ((6253e59c-516e-4368-9fcf-c585a7ccf4ae))
			- ((6253e5c6-bb64-4b72-bfe9-cd78f359e346))
			- 具体来说有两种实现方式: 预写日志(WAL)和两阶段提交(2PC)
			- ##### 预写日志(write-ahead-log, WAL)
				- ((6253e60f-c373-4f39-909c-d0c9a83f423f))
				- 1. 先把结果数据作为日志(log)状态保存起来
				  2. 进行检查点保存时,也会将这些结果数据一并做持久化存储
				  3. 在收到检查点完成的通知时,将所有结果一次性写入外部系统
				- ((6253e687-4ba8-422a-b07a-cdbd22aa3d97))
			- ##### 两阶段提交(two-phase-commit, 2PC)
				- ((6253e6d2-dc5d-423c-b00c-3b775b2cb914))
				- 1. 当第一条数据到来时,或者收到检查点的分界线时,Sink任务都会启动一个事务
				  2. 接下来接收到的所有数据,都通过这个事务写入外部系统;这时由于事务没有提交,所以数据尽管写入了外部系统,但是不可用,是"预提交"状态
				  3. 当Sink任务收到JobManager发来检查点完成的通知时,正式提交事务,写入的结果就真正可用了
				-
		-