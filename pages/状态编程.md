- ((625140c4-b89e-4392-a42c-5089e0843a08))
- ## Flink中的状态
	- ((625140eb-17bc-4baf-884b-3cb9611c3e54))
	- ### 有状态算子
		- 算子任务分为无状态和有状态两种情况
		- 我们之前讲到的基本转换算子,如map、filter、flatMap,计算时不依赖其它数据,就都属于无状态算子
		- ((62514144-c79b-4407-82f8-ecf1dbdfd6eb))
		- 有状态算子任务,除了当前数据之外,还需要其它数据来得到计算结果.这里的"其他数据",就是所谓的状态.如我们之前讲过的聚合算子、窗口算子等都属于有状态的算子
		- ((6251418d-8e48-4f2b-b410-e8dc58aa16db))
	- ### 状态的管理
		- ((6251421e-4bdd-4ad6-bc71-93981ab69b1f))
		- 内存、分布式拓展、持久化备份恢复、重组调整
	- ### 状态的分类
		- #### 托管状态(Managed State)和原始状态(Raw State)
			- ##### 托管状态
				- 托管状态由Flink统一管理,状态的存储访问、故障恢复和重组等一系列问题由Flink实现
				- 对于具体的状态内容,Flink也提供了值状态(ValueState)、列表状态(ListState)、映射状态(MapState)、聚合状态(AggregateState)等多种结构
			- ##### 原始状态
				- 原始状态是自定义的,相当于是开辟了一块内存,需要我们自己管理,实现状态的序列化和故障恢复
				- [[#red]]==只有在遇到托管状态无法实现的特殊需求时,我们才会考虑使用原始状态;一般情况下不推荐使用==
			- 接下来我们的重点就是托管状态(Managed State)
		- #### 算子状态(Operator State)和按键分区状态(Keyed State)
			- 在Flink中,一个算子任务会按照并行度分为多个并行子任务执行,而不同的子任务会占据不同的任务槽.由于不同的slot在计算资源上是物理隔离的,所以Flink能管理的状态在并行任务间是无法共享的,每个状态只能针对当前子任务的实例有效
			- 而很多有状态的操作(如聚合、窗口)都要先做keyBy进行按键分区.按键分区之后,任务所进行的所有计算都应该只针对当前key有效,所以状态也应该按照key彼此隔离.在这种情况下,状态的访问又会有所不同
			- 基于这样的想法,我们可以将托管状态分为两类:算子状态和按键分区状态
			- ##### 算子状态
			  collapsed:: true
				- 状态作用范围限定为当前的算子任务实例,也就是只对当前并行子任务实例有效
				- ((6251454a-62c0-4f11-a9dc-f14fb4746252))
				- 算子状态可以用在所有算子上,使用的时候其实就跟一个本地变量没什么区别.
				- 区别是需要持久化,所以在使用时我们还需进一步实现CheckpointedFunction接口
			- ##### 按键分区状态
			  collapsed:: true
				- 状态是根据输入流中定义的键（key）来维护和访问的，所以只能定义在按键分区流（KeyedStream）中，也就keyBy之后才可以使用
				- ((62514617-813a-4964-820b-5a9c9c44a3af))
				- 可以通过富函数类（Rich  Function）来自定义Keyed State，所以只要提供了富函数类接口的算子，也都可以使用Keyed State
				- 即使是map、filter这样无状态的基本转换算子，我们也可以通过富函数类给它们“追加”Keyed State，或者实现CheckpointedFunction接口来定义Operator State；从这个角度讲，Flink中所有的算子都可以是有状态的
			- 无论是算子状态还是按键分区状态,它们都是在本地实例上维护的,也就是说每个并行子任务维护着对应的状态,算子的子任务之间状态不共享
-
- ## 按键分区状态(Keyed State)
	-